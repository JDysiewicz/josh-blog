---
title: "What is 'Good' Software?"
slug: "what-is-good-software"
author: "Joshua Dysiewicz"
date: "13 November 2020"
readingTime: "ðŸ“– x min"
spoiler: "Software design principles"
---

## Why.
The most important question a person can ask when trying to learn something new is "**why?**".

- **Why** should I use a functional component over a class component?
- **Why** should I use promises over callback functions?
- **Why** should I have each React component in its own file?

Along that line of thinking, you might rightly ask *"**Why** have you started an article on software design principles with an esoteric discussion about language?"*. Well, it's because the **why** becomes incredibly important when we discuss what makes something **"good"**. In response to the above questions, we could easily say *"Because it makes for better code"*, but this begs the question: **Why do these things make code better?**

## What Makes Code 'Good'
'Good' code is somewhat subjective, and somewhat objective. To elaborate, let me ask you: what makes someone attractive? We can make some general statements, for example facial symmetry is generally regarded as an attractive trait [https://www.sciencedirect.com/science/article/abs/pii/S1090513801000836] (objective), however it is also depends on the person (subjective). Dividing 'good' into subjective and objective terms allows us to focus on certain aspects of software construction, and allows us to understand why, for instance, promises are better than callbacks in most cases.

### Objectively Good Code
Objectively good code means that we can extract out all personal feelings and attachments, and focus purely on factual evidence. This is where design principles such as SOLID come into play.


### Subjectively Good Code


//////////////////////////////////////////////

'Good' software is incredibly hard to define, and can be incredibly subjective. However, we can point to some objective traits that make some code better than others. Think of this as defining what makes someone attractive: there are well studied phenomena about what makes an individual objectively more attractive (e.g facial symmetry [https://www.sciencedirect.com/science/article/abs/pii/S1090513801000836]), however it can also be personal preference. In general, however, good software is:

- **Funcional**: It does the job you wanted it to.
- **Maintainable**: It is easy understand, easy to edit/add new features, and easy to fix things when they go wrong.
- **Robust**: It is hard to break, hard to exploit, and handles errors when they occur.

### Funcional
This part of good software deals with requirements, and where methodologies "agile development" make their home. Every decision we make should have some reason as to how it makes steps towards some overarching goal. If you create the greatest JavaScript framework in the world but you were asked to create a twitter clone, then you've provided an excellent answer to the wrong question. This is the realm of usability, and agile frameworks.

Code that is functional provides a correct answer to a given question. Take, for instance, the following two code snippets which both accomplish the same thing.

```jsx
const callAPI = async () => {
	const data = await fetch("https://jsonplaceholder.typicode.com/todos/1");
  	return data;
};

callAPI()
```

```jsx
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg){
    try {
        var info = gen[key](arg); var value = info.value;
    } catch (error) {
        reject(error); return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}

function _asyncToGenerator(fn) {
    return function () {
        var self = this, args = arguments;
        return new Promise(function (resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}

var callAPI = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
    var data;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return fetch("https://jsonplaceholder.typicode.com/todos/1");

          case 2:
            data = _context.sent;
            return _context.abrupt("return", data);

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function callAPI() {
    return _ref.apply(this, arguments);
  };
}();

callAPI();
```

Now, I don't think its particularly controversial to prefer the first snippet. However, what if the purpose of these snippets was to call an API in a way that was compatible with all browsers? Well, suddenly the first snippet is now *awful* code for this task, as IE11 doesn't support the async/await syntax (let's ignore that babel exists to illustrate the point here, as the actual correct response here is to use the first snippet but transpile it down to ES2015). This goes to show that good code is code which provides the functionality expected of it.

### Maintainable
Code is maintainable if you can come back to it 6 months later and understand how it works in a few minutes. It is also easy for other developers to pick up and work on when you're not around. This is the realm of readability, naming conventions, decoupling, and extensibility.

### Robust
Code is robust if it accounts for all possibilities, and handles errors gracefully. This is the realm of testing and error handling.


## Software Development Philosophies
There are many, *many* different philosophies when it comes to writting software. There are philosophies focusing on the large-scale development of software (such as test-driven development and agile methodologies), and those focusing on very language-specific features (idiomatic code). Each of these philosophies attempts to make code 'better' according to the three basis outlined above (functionality, maintainability, and robustness). For instance, using a test-driven development philosphy (where tests are written before code is) will ensure your code is more robust as you are thinking about testing and error handling from the very begining. For the most part, we will touch on philisophies and principles which seek to make code more maintainable, as this is what we generally think of when we think of good software in isolation. Functionality must be compared against user requirements, and robustness must be compared against tests. It should be noted, however, that these principles are:

1. Language aganostic: These principles are generalised to all programming languages, and so may be easier to implement in one language over another.
2. Guidelines: Don't be too dogmatic about these principles; remember, we only follow these so long as they increase the maintainability of our code by one means or another, if they become more of a hinderence then feel free to break them.

### SOLID
I decided to extract this section to a separate article, as this article began to become unwieldly long. For a discussion on what SOLID is and how we can apply it to React, <a href="solid-principles-in-react">please view my separate article here</a>.

### DRY
**D**on't **R**epeat **Y**ourself is the principle that each piece of functionality should only be written the minimum number of times it is needed. Variables are a great example of this:

```jsx
const multiplyByNum = 2 * 3;
const addedNum = 2 + 7;
const subtractedFromNum = 2 - 1;
```

This may work, however there is a common theme among all the values: each one deals with the number `jsxÃ·2`. If we want to change the number to `jsxÃ·3`, we would have to change every instance of `jsxÃ·2`.

```jsx
const multiplyByNum = 3 * 3;
const addedNum = 3 + 7;
const subtractedFromNum = 3 - 1;
```
Not only is this tedious, but it is also prone to errors as it could be very easy to miss an instance of `jsxÃ·2` is our codebase was larger. Therefore, to save this, we create a `jsxÃ·num` variable. That way, if we ever want to change the number, we alter `jsxÃ·num` and can be assured that every instance of `jsxÃ·2` becomes a `jsxÃ·3`.

```jsx
const NUM = 3;
const multiplyByNum = NUM * 3;
const addedNum = NUM + 7;
const subtractedFromNum = NUM - 1;
```
For this reason, this principle is also refered to as the **S**ingle **S**ource **O**f **T**ruth (SSOT) principle, as we aim to extract out all commonalities into a single variable which will be used as the source of truth for the entire application.

#### Overdoing it
While this sounds perfect in theory, the reality is often not so simple. Dan Abramov has a great talk about what happens when you dogmatically stick to the DRY principle too much (appropriately named "The WET codebase", **W**rite **E**verything **T**wice) [https://www.deconstructconf.com/2019/dan-abramov-the-wet-codebase]. When we attempt to abstract out common code, we may accidently create a very poor abstraction. In the end, this ends up being worse than no abstraction at all. At this point, our code has become less maintainable by sticking to a principle too strongly. A principle is only good if it actually makes your code better (addresses functionality, makes things more maintainable, or makes it more robust). Don't be dogmatic about any one principle.

> "We try so hard to avoid the spaghetti code that we create this lasagna code, where there are so many layers that you don't know what's going on anymore at all" - Dan Abramov


### YAGNI
https://xkcd.com/974/

**Y**ou **A**in't **G**onna **N**eed **I**t ties in to answering the right question. Build what is required now, and build the features you may need in the future, in the future. For instance, if you're making a weather app the get the weather based on postcode in the UK, there's no need to add support for zipcodes in USA. Sure, one day you might want to add support for this - if your codebase is maintainable (see below) it shouldn't be an expensive addition. However, trying to do this now when it won't be needed now will waste time, and have incurred cost of building, cost of carry, and cost of delay [https://martinfowler.com/bliki/Yagni.html]. 

YAGNI doesn't mean "don't plan for future extensibility", it means "meet the current needs before meeting needs of the future". Facebook didn't start out with x million servers and data warehouses, because at the time YAGNI. However, once they did once they needed it.

#### Overdoing it
There are some changes that would be expensive to make down the line. If you know if 6 months time you'll need to be able to support 1 million users but right now you only need to support 100,000, maybe you should chosse a database which has the capability of more than 200,000. Migrating 200,000 users to another database in 6 months time would be way harder than just taking the initial time hit to set up the larger database now in preperatino for the future. [https://martinfowler.com/bliki/Yagni.html]


### KISS
**K**eep **I**t **S**imple, **S**tupid states that systems should be as simple as possible, and that unecessary complexity should be avoided. This, however, is a truism. **Obviously** we should avoid "unecessary complexity" - it is *by definition* "unnecessary". So, how can we decide what "unecessary complexity" is? Well - we must look back at our criteria for good software:

- Does this change create the desired **functionality**?
- Does this change make the codebase easier to **maintain**?
- Does this style of coding make the system more **robust**?

Even if its the coolest and greatest feature in the world, it's unecessary complexity if it doesn't answer "yes" to at least one of the above questions. For example, if we need to implement some sorting functionality to our codebase, we *could* create our own sort function...[https://www.digitalocean.com/community/tutorials/js-understanding-merge-sort]

```jsx
const merge = (arr1, arr2) => {
  let sorted = [];

  while (arr1.length && arr2.length) {
    if (arr1[0] < arr2[0]) sorted.push(arr1.shift());
    else sorted.push(arr2.shift());
  };

  return sorted.concat(arr1.slice().concat(arr2.slice()));
};

const mergeSort = arr => {
  if (arr.length <= 1) return arr;
  let mid = Math.floor(arr.length / 2),
      left = mergeSort(arr.slice(0, mid)),
      right = mergeSort(arr.slice(mid));

  return merge(left, right);
};

const sortedArr = mergeSort[3,2,5,4,1];
console.log(sortedArr) // [1, 2, 3, 4, 5]
```

However, JavaScript has a built in `jsxÃ·Array.sort()` method which implements a sorting algo for us (quicksort or merge sort depending on your runtime environemnt).

```jsx
const sortedArr = [3,2,5,4,1].sort((a,b) => a-b);
console.log(sortedArr) // [1, 2, 3, 4, 5]
```

99% of the time, someone has already solved part of the problem you're working on and there is a library or existing codepen out there. This is the beauty of open source software - all you have to do is find it. KISS, don't reinvent the wheel.

#### Overdoing it
Sometimes, the simplest solution *isn't* the best. Sometimes, that codepen/library doesn't quite have the functionality you need from it. At this point, it's appropriate to add in some additional complexity. For instance, take the Two Sum problem. We have an array of values, and we want to find a a pair of numbers in the array which sum to some value.

```jsx
const sum = 52;
const array = [1, 22, 33, 15, 42, 23, 72, 51]
```

The simplest solution here is just to check each value in the array twice:

```jsx
function twoSumBad(arr, sum){
    for (let i = 0; i < arr.length; i++){
        for (let j = 0; i < arr.length; j++){
            if (arr[i] + arr[j] === sum){
                return [arr[i], arr[j]];
            }
        }
    }
    return false;
}
```

However, this involves checking every value in the array twice and so the time taken to complete this operation will increase with the square of our array length (see big O notation). A more complex, yet *better* solution is to keep track of the values we have already seen, therefore we only need to go through the array n times instead of n^2 times.

```jsx
function twoSumBetter(arr, sum){

    let seenNumbers = new Set();

    for (let i = 0; i < arr.length; i++){
        const neededValue = sum - arr[i];

        if (seenNumbers.has(neededValue)){
            return [arr[i], neededValue];
        } else {
            seenNumbers.add(arr[i]);
        }
    }

    return false;
}
```
Glossing over some details here, this implementation of the two sum problem is more complex, yet runs much faster than the simple implementation. It is up to your experience as a developer, and the experience of those around you, to know when complexity is needed or when complexity is necessary.


