---
title: "Deep Dive: How JS Runs (2)"
slug: "how-js-runs-2"
author: "Joshua Dysiewicz"
date: "24 October 2020"
readingTime: "ðŸ“– 5 min"
spoiler: "Continuing the Deep Dive series, this post uses the same approach to explore closures in JS."
---


## How JavaScript Code Runs: Closure

### Disclaimer
This is part two in a **four** part series dedicated to exploring how JS code is actually executed, and how everything comes together to form some of the best features of the language, like asynchronous JS and async/await. Before reading this, I'd highly recommend reading the **first** part in this series, <a href="/article/how-js-runs-1">JavaScript Deep Dive: The Principles of How JS Runs (1)</a>.

### Higher Order Functions
Before exploring what a *closure* is, we first need to understand **higher order functions**. This is a fancy term, which is used to describe a function that **takes** another function as an argument, or **returns** another function.
```javascript
function higherOrderFunction (callback){
    callback();
};

function callback(){
    console.log("Hi there");
};
```
`higherOrderFunction`, aptly named, is a **higher order function** as it takes a function as an argument. Another example of a **higher order function** is one which **returns** another function, such as `higherOrderToo` below.

```javascript
function higherOrderToo (){
    function inner(){
        console.log("Hi there");
    };

    return inner;
};
```
#### Deeper dive
Let's run through what actually happens during this process as we have done before.

```javascript
function createFunction(){                      // Line 1
                                                // Line 2
    function inner(num){                        // Line 3
        return num + 2:                         // Line 4
    };

    return inner;                               // Line 7
};

const generatedFunction = createFunction();     // Line 10
const result = generatedFunction(3);            // Line 11
```
1) **Line 1**: Entire function definition stored in a section of the **global** memory which we call `createFunction`.
2) **Line 10**: We skip the rest of the function, as it is not invoked yet. We set aside some space in **global** memory and call it `generatedFunction`. Its value is currently **not there** as it is set to the **return** value of `createFunction()`.
3) **Line 2**: We invoked `createFunction`, and so our thread of execution enters the function and we create a new execution context with **local memory**.
4) **Line 3**: We provision a space in **local memory**, call it *inner* and place into it the entire function definition of `inner`.
5) **Line 7**: We aren't invoking `inner`, and so we jump down to the **return** statement, where we go into **local** memory, find the section labelled *inner* and **return this out of the `createFunction` call**. Then we throw away everything in the **local** memory, re-enter the **global** execution context and place `inner` into the section of memory we called `generatedFunction`.
6) **Line 11**: We set aside some space in global memory, call it *result* and pass into it the **return** value of executing `generatedFunction` with the **parameter** of **3**. We then go to `generatedFunction` in **global** memory and execute the code there, which is the same as defined in `inner`.
7) **Line 3**: We enter a new function call, and so enter a new **execution context** and place `generatedFunction()` onto the **call-stack**. NOTE - we are **not** going back into the `inner` function defined within `createFunction` - `createFunction`'s execution context has already been thrown out and so `inner` no longer exists). Within the execution context of `generatedFunction`, we assign some space in **local** memory, call it *num* and place into it the value **3**.
8) **Line 4**: We return from the function the evaluation of `num + 2` which is `3 + 2` which is the value **5**. We then return **5** out of this function call and assign this to the space in **global** memory we called *result*. We then throw away the execution context of `generatedFunction`, including its **local** memory. 

### The C.O.V.E (The Backpack)
So I've mentioned a lot about how once an execution context completes, **everything within it is thrown away**. This is true, however we are left with an interesting case!

```javascript
function outer(){
    let num = 1;
    function inner(){
        console.log(num)
    };
    return inner;
};

const generatedFunction = outer();
generatedFunction() // 1
```
Following similar logic to above, we expect this `num` to be thrown away when `outer()` finishes executing, as **everything in the local memory is thrown away after it finishes executing**. However, running this code shows us that, even though `num` has been thrown away, `inner()` (or, rather, our `generatedFunction()`) is **still able** to access it.

The concept of a returned function retaining access to variables it **had** in a **local** memory before being thrown away is called **closure**. One way to imagine this is that our **returned function** is also returned with a **backpack** containing everything that it had access too in **local memory** before it was thrown away when the execution context that held those variables ended.

```javascript
function outer(){
    let num = 2;
    let name = "Sally";

    function inner(){
        console.log(num);
        console.log(name);
    };

    return inner;
};
```
As an example, when we return `inner` from `outer`, we can imagine we are actually returning **`inner + {num: 2, name: "Sally"}`** together, where this `inner` is **linked** to the **object** containing the **local memory/variable environment** that `inner` had access to (remember lexical scoping? `inner` was defined within the `outer` block and so had access to all the variables defined in `outer`). For this reason, this **variable environment object** we receive (which is attached to the function it was returned with) is sometimes called the **Closed Over Variable Environment**, or **COVE**. Now, confusingly enough, this COVE/backback of variables can *also* be referred to as a *closure*. **Closure** can refer to both the *process* of returning a function and a variable environment from a function, **and** the *COVE/backpack itself*. For this reason, I will always try to call the backpack containing the variables the **COVE**, and the process of doing this **closure**.

### Using the COVE
The thing that makes **closure** so powerful, is that we can actually **modify** the values in the COVE.
```javascript
function outer(){
    let count = 0;

    function inner(){
        count ++;
        console.log(count);
    };
    return inner;
};

const generatedFunction = outer();
generatedFunction() // 1
generatedFunction() // 2
generatedFunction() // 3
```
When we **return** the function definition of `inner` into *generatedFunction* in **global** memory, we **also** store its COVE in the **global** memory linked to it. This means that, when we execute `generatedFunction()` and we come across `count`, JS first checks the **local memory** of our execution context (`generatedFunction()`): it checks "Do you define a variable called `count` here?". If there is no definition for it in **local memory**, JS then goes to check if there is a COVE **linked** to this function in **global memory**. Here, it finds a definition for `count`, and increments it with `count ++`. Therefore, the `count` in the COVE is now **1** instead of **0**. (*As a side note, assuming that the variable wasn't found in the COVE, JS would travel up the lexical scopes until it found it, or reached global and throws a `ReferenceError`.*)

Another great power of **closure** is that this COVE is *specific to that instance of the function*.

```javascript
function outer(){
    let count = 0;

    function inner(){
        count ++;
        console.log(count);
    };
    return inner;
};

const firstFunction = outer();
const secondFunction = outer();
firstFunction()     // 1
firstFunction()     // 2
secondFunction()    // 1
firstFunction()     // 3
secondFunction()    // 2
```

Remember, each backpack is tied to **that section in global memory where the function definition is stored**. Here, we have **two** sections in global memory (*firstFunction* and *secondFunction*) which **both** hold the same function definition (that of `inner`), however they **are** in **separate** sections in memory, and so will have **different COVEs**. This means we can independently keep track of each count from each function.

Closures are used all over JavaScript, once you notice them. As I explained in my post about **Scope and Closure**, closures are how the `useState` hook works in React. They are also vital to correct functioning of **iterators** and therefore to understanding how **generators** work. This, along with the **asynchronous JavaScript** stuff we'll cover in **part three**, forms the foundation of all the cool parts of the JavaScript language.