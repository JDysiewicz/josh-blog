---
title: "React: How It Works"
slug: "react-how-it-works"
author: "Joshua Dysiewicz"
date: "14 September 2020"
readingTime: "ðŸ“– 20 min"
spoiler: "An overview of how react works internally, and how to use it to build a counter app."
---

import { Link } from "gatsby";

**NOTE** - This is a pretty long read. Don't feel like you have to read all of this at once - take breaks, go for a walk, etc. Between this, <Link to="/articles/react-lifecycle-methods">component Lifecycle</Link>, and <Link to="/articles/react-hooks">hooks</Link>, there is about an **hour** of reading about React. However, I urge you to stick with it. React is hard, and to cover everything the framework has to offer in less than an hour of content is near impossible. This should, however, provide a great spring board for you to dive into other resources, and start writing your own React projects. There's a lot to learn with React, but you don't need all of it to be able to make something cool!

## React Under the Hood
While we can build websites with vanilla JavaScript (no additional packages installed), there are certain things which make this either difficult or tedious. There are common features to websites which others have already implemented, so why would we spend time creating our own features from scratch every time? You may want an image carousel on your website, however you don't have to spent time working out how to make the internals of it work because <a href="https://www.npmjs.com/package/react-slick">someone else already has</a>. The beaty of this, is that these premade sections of javascript (called *packages*) 
React is a JavaScript **framework** 

```bash
npm install react react-dom
```
into our terminal. What? Why are there two imports there? Good question! The React framework is mainly comprised of two parts: the various functions and properties which allow us to create *components*, and the various functions and properties which allow us to *simulate* the **D**ocument **O**bject **M**odel (DOM). As mentioned previously, the DOM is the hierarchical structure of our webpage. The `react-dom` import allows us to access functions the can construct and insert a *virtual* DOM into the actual DOM on a website.

```javascript
ReactDOM.render(
    <App />,
    document.querySelector("#root")
);
```
Therefore, almost all React project will have the same structure: an `index.js` file in which we import `react` and `react-dom`, and an `App.js` file which defines our application.

**index.js**
```javascript
import React from "react";
import ReactDOM from "react-dom";

import App from "./components/App";

ReactDOM.render(
    <App />,
    document.querySelector("#root")
);
```

**App.js**
```javascript
import React from "react";

const App = () => {
    return (
        <div>Hello, world!</div>
    );
};

export default App;
```

Now there's a lot to unpack in these two files, but this is in essence how React works - remember, you're still writing **javascript** at the end of the day. Our browsers don't know what `ReactDOM.render()` does, and so when we write this it is actually converted into plain old vanilla javascript that our browsers understand. Take for instance our `App.js` file above - when we run this code, it actually gets converted into the following:

```javascript
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(require("react"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const App = () => {
  return /*#__PURE__*/_react.default.createElement("div", null, "Hello, world!");
};

var _default = App;
exports.default = _default;
```

Removing some of the fluff that we aren't interested in, we are left with: 

```javascript
const App = () => {
  return /*#__PURE__*/_react.default.createElement("div", null, "Hello, world!");
};

var _default = App;
exports.default = _default;
```

While looking different from what we wrote in `App.js`, we can still understand what this might be doing! It seems that our *functional component* (more on those later), `App`, has been converted into a call to `_react.default.createElement` with the parameters `"div", null, "Hello, world!"`. The `createElement` function is defined in that `react` library we imported at the top - this is why we need to import it into **every** React file we make: it is fundamental to gaining access to these sorts of functions. While this example may seem simple, you can imagine this gets out of hand fast:

```javascript
import React from "react";

const AnotherComponent = () => {
	const name = "Josh";
  	return(
    	<div>
        <span>Hello, {name}</span>
      	</div>
    );
};

const App = () => {
    return (
      <div>
        <div>
        	<div>Hello World!</div>
      	</div>
      	<AnotherComponent />
        </div>
    );
};

export default App;
```
Adding in another component and rendering this within App leads to the following code seen by the browser:

```javascript
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(require("react"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const AnotherComponent = () => {
  const name = "Josh";
  return /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("span", null, "Hello, ", name));
};

const App = () => {
  return /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("div", null, "Hello World!")), /*#__PURE__*/_react.default.createElement(AnotherComponent, null));
};

var _default = App;
exports.default = _default;
```

or, more "*simply*":

```javascript
const AnotherComponent = () => {
  const name = "Josh";
  return /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("span", null, "Hello, ", name));
};

const App = () => {
  return /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("div", null, "Hello World!")), /*#__PURE__*/_react.default.createElement(AnotherComponent, null));
};

var _default = App;
exports.default = _default;
```

Notice how we end up with multiple nested calls to `_react.createElement`? This would be horrible to write and debug, and is not very clear in what the end result will actually *look* like. This is why React simplifies this process by allowing us to use *alternate syntax* which is much easier to see what's going on, then it can use another library to *transpile* it down to another version of code which will be executed by browsers. You can try this for yourself by going to [babeljs](https://babeljs.io/repl). *Babel* is the library which does all this transpiling to alternate forms of javascript, and converts our somewhat nice looking `App.js` file to the hoard of nested `createElement` calls for our browser to parse.

## npx create-react-app
Now you might rightly think "I've never installed `react`, `react-dom`, or `babel`, yet my code works just fine". This is where `create-react-app` comes in. **C**reate-**R**eact-**A**pp (CRA) does all the heavy lifting for us when it comes to creating react projects. It installs all the dependencies we'll need for us, it starts up a server to host our react app (usually on port 3000), creates a bunch of starter files, and populates our `package.json` with various **scripts**, such as `start` which will open up our react project when we call 

```bash
npm run start
```

or, more simply,

```bash
npm start
```
That's why it takes 3/4 minutes to actually set up the folder, and if you've every inspected to size of the folder, a simple `Hello, world!` like that above is about **185Mb** in size. The majority of that is taken up by the `node_modules` folder, which is where all the dependencies such as `babel` are stored.

## How React Works
Now we've touched on the general structure of a React app, let's actually breakdown what's going on. In our `create-react-app` project folder, we'll have an `src` (source) folder which will store the vast majority of our relevant files. There is also a `public` folder, in which is kept our `index.html`. Inspecting this `index.html` will reveal an extremely short file, consisting mainly of overhead with a single interesting line:

```html
<div id="root"></div>
```

Remember that line referencing `root` in our `index.js` file above? Here it is again:.

**index.js**
```javascript
import React from "react";
import ReactDOM from "react-dom";

import App from "./components/App";

ReactDOM.render(
    <App />,
    document.querySelector("#root")
);
```
What this `ReactDOM.render` function is doing is taking everything defined in `App`, and shoving it into that `<div>`. We could think of this as simply:

```html
<div id="root">
    <!-- Everything in App gets put in here -->
</div>
```
Therefore, lets take the example `App.js` from above, which returns a single line of "*html*" (we'll touch on that in a minute): `<div> Hello, world! </div>`

**App.js**
```javascript
import React from "react";

const App = () => {
    return (
        <div>Hello, world!</div>
    );
};

export default App;
```
React will render this inside our `index.html`, such that the end result will be:

```html
<!-- Stuff above -->
<div id="root">
    <div>Hello, world!</div>
</div>
<!-- Stuff below -->
```

That is all React is doing. It looks like magic, and the inner workings of it certainly are, but in reality the concept is relatively simple: "*write all your HTML inside javascript files, and render them all within a single div in index.html*". Now, when we have many components all nested within each other, `props` flying around, `state` to worry about, and various other libraries inserting and deleting things (`react-router, redux, axios...`) this can get extremely complicated, but at the end of the day this is all React does.

### Components
Components form the building blocks with which we make React applications. Think of them as individual contained entities which house some HTML to be displayed and JS code to be executed. They come in **two** flavours: *Functional Components* and *Class Components*.

We shall start with **Class components**, however note there has been a shift towards **functional** components in recent years for reasons that we will discuss later. A class component, as you'd think, is defined as a `Class` in javascript (we shall leave discussions of why classes don't really exist in JS for another day).

```javascript
import React from "react";

class App extends React.Component {
    render(){
        return (<div>Hello, world!</div>)
    };
};

export default App;
```
We state that `App` shall be a class with the `class App` line, and then say that it will `extend` another class defined in the `react` library called `Component`. This means that our class, `App`, will have access to all the methods and properties the smart guys at Facebook placed into the `React.Component` class. It has a `render()` method (the inner workings of which is defined in `React.Component`), from which we `return` the HTML we want to display to the user. We can assign other methods or properties to our class too - though we don't need to use a **declaration** to do so (no need to say `let`, `const` or `var` when defining a new method or property):

```javascript
import React from "react";

class App extends React.Component {
    name = "josh";

    age = 23;
    
    render(){
        return (<div>Hello, world!</div>)
    };
};

export default App;
```
To access these variables, we need a new bit of syntax. Remember earlier how I mentioned that we write "*HTML*" in React? Well I lied - it's technically **J**ava**S**cript **X**ML, or **JSX** for short. JSX is pretty much HTML, however we can insert JS expressions into it with the `{expression}` syntax. For example:

```javascript
const idForDiv = "div-1";
<div id={idForDiv}>This div now has the id="div-1"</div>
```
Here we place the `{ }` brackets within the `<div>` an execute a JS expression inside, then assign that value to the `id=` attribute. We can do a similar thing with components:

```javascript
import React from "react";

class App extends React.Component {
    name = "josh";

    age = 23;
    
    render(){
        return (<div>Hello, {name}!</div>)
    };
};

export default App;
```
**NOTE** - The above feels like it should output

```html
<div>
    Hello, josh!
</div>
```

However, if you try to run this you might be faced with an error. This is one of the quirks of class components which has caused a shift towards functional components. When we create an *instance* of our class component, as we do when we call it in our `ReactDOM.render()` call, we are creating an `Object`. As such, when we attach properties/methods to it, such as `name` above, we never *declare* them to JS to say "Hey, set aside some memory to store 'josh' and call it 'name'". Therefore, to access a property **on** an object from **within** the object itself, we must tell JS to look inside the current object instead of looking for a declared variable. We do this by using the aptly named `this` keyword. This gets into the weeds of *execution context* and *lexical scope*, and so we will not touch this except to mention that the correct way to use a variable attached to an object, **WITHIN** the object itself is to reference `this` as a prefix to the method/property.

```javascript
import React from "react";

class App extends React.Component {
    name = "josh";

    age = 23;
    
    render(){
        return (<div>Hello, {this.name}!</div>)
    };
};

export default App;
```
*This* (Pun intended) is the correct code that will output

```html
<div>
    Hello, josh!
</div>
```

Similarly, we would need to reference `this` when calling a method defined in our class component:

```javascript
import React from "react";

class App extends React.Component {
    name = "josh";

    age = 23;

    printAge = function () {
        console.log(this.age)
    }
    
    render(){
        this.printAge();
        return (<div>Hello, {this.name}!</div>)
    };
};

export default App;
```

Here, we define a `printAge` method on the class `App` which will print `this.age`, and we call it within our `render()` method. 

**Function** components avoid the usage of `this`, and are instead treated as, well, functions: we can define functions within them, define variables within them, and call them all without having to worry about `this` as we are actually declaring variables. Here is a functional component version of the above `App` which will behave in the exact same way.

```javascript
import React from "react";

const App = () => {
    const name = "josh";
    const age = 23;

    const printAge = () => {
        console.log(age)
    };

    printAge();

    return(<div>Hello, {name}!</div>)
};

export default App;
```

Notice a few differences: firstly, we do not extend `React.Component` as we have no need to access the `render()` method - we simply return from the function what we want to render. Secondly, we define it as an arrow function instead of a class (hence the name *functional component*). Thirdly, we define properties and methods as we would in normal javascript - with a declarative statement `let`, `const` or `var`. Fourthly, we call `printAge()` within the function body itself - this is because the entire function is run again when the component is called to re-render itself (more on this later), as compared to the `class` component where only code written in the `render()` method would be run after initialization. Lastly, and perhaps most importantly, no faffing about with `this` (can you tell im biased?).

### render
A quick aside - I've mentioned *render* quite a few times so far. This means that our JS will be run, and the resulting JSX will be displayed to the screen by being put into that `<div id="root">` mentioned previously. React decides when to *re-render* a component, usually when a user visits a page which we specify needs to display a certain bit of JSX, or when our **state** updates - more on state later.

### Props
Now, as vain as I am, it would be nice if people could write their *own* name and age within our component. This is simplified for us (once again) by React, as react will pass an object called `props` to our functional and class components whenever they are called. For instance, in our `index.js` where we call our `App` component, we can pass down a variable by using that JSX syntax again:

**index.js**
```javascript
import React from "react";
import ReactDOM from "react-dom";

import App from "./components/App";

ReactDOM.render(
    <App userName={"Emily"} age={99} />,
    document.querySelector("#root")
);
```

This will attach the `userName` and `age` properties to the `props` object that React passes down whenever we call a component. We access this within `App` by passing the the `props` component into our function declaration.

**App.js**
```javascript
import React from "react";

const App = (props) => {
    const name = props.userName;
    const age = props.age

    const printAge = () => {
        console.log(age)
    };

    printAge();

    return(<div>Hello, {name}!</div>)
};

export default App;
```
This allows us to access all the properties placed onto props when `App` is called. We could even add another object to this, for instance:

**index.js**
```javascript
import React from "react";
import ReactDOM from "react-dom";

import App from "./components/App";

ReactDOM.render(
    <App person={ {name: "Emily", age: 19} } />,
    document.querySelector("#root")
);
```

```javascript
import React from "react";

const App = (props) => {
    const name = props.person.name;
    const age = props.person.age

    const printAge = () => {
        console.log(age)
    };

    printAge();

    return(<div>Hello, {name}!</div>)
};

export default App;
```

Notice the `{ {} }` syntax when passing an object into JSX - one set of curly braces for declaring a JS expression, a second set to declare the object.

Class components treat things differently - we do not have a function declaration to access the `props` object, but luckily React passes this to our class for us, and so we can immediately access it using the `this.props` syntax, however everything else remains the same as it was in with functional components - the only difference is *how* we access the props object.

**index.js**
```javascript
import React from "react";
import ReactDOM from "react-dom";

import App from "./components/App";

ReactDOM.render(
    <App name={"Emily"} age={19} />,
    document.querySelector("#root")
);
```

**App.js**
```javascript
import React from "react";

class App extends React.Component {

    printAge = function () {
        console.log(this.props.age)
    }
    
    render(){
        this.printAge();
        return (<div>Hello, {this.props.name}!</div>)
    };
};

export default App;
```

### State
State is why class components were needed for so long, and why functional components were second choice for most of React's lifetime. Now we have **Hooks** which eliminates this, however let's start from the beginning.

We can pass some information down into a component via `props`. Wouldn't it be great if we had some way of continually feeding information to a component, *from* the component itself? What if we could keep track of some changing variable **on** the component itself? An example might be a simple counter.

```javascript
import React from "react";

const Counter = () => {
    let count = 0;

    return(
        <div>
            <h1>The count is: {count}</h1>
            <button onClick={/* Increment the count upon click */}></button>
        </div>
    );
};

```
Okay this looks good, so after we click we then need to re-run our function to display the new `count`-- oh wait!

```javascript
let count = 0; // This line would reset our count again upon re-rendering
```

We are then left in a stalemate - either we re-render our component to display the new count, promptly resetting it to `0`, or we do not re-render our component. `count` would increase, however our component would **NOT** re-render and display the new `count`. To get around this tricky scenario, we need to introduce a new concept in React called **state**.

This is the reason why class-based components were used for so long. Up until the release of *React Hooks* in 2019, state could *only* exist on a class component. The way we add this in is a bit convoluted, so we'll go through it slowly.

```javascript
import React from "react";

class Counter extends React.Component {
    constructor(props){

    };
    
    render(){
        return (<div></div>)
    };
};

export default Counter;
```
The first thing we do is to add a `constructor` function to our component, and feed in our `props`. This constructor is called when the `Counter` is first instantiated (when `<Counter />` is **first** called), however **not** when it is re-rendered. This means we can initialize our `count` to be `0` without having to worry about resetting it on every re-render. Next, we call a built-in function called `super` passing in our props:

```javascript
import React from "react";

class Counter extends React.Component {
    constructor(props){
        super(props)
    };
    
    render(){
        return (<div></div>)
    };
};

export default Counter;
```

This is a built-in function which will allow us to access all the properties and methods on the `parent class` of Counter (which would be `React.Component`). Without this call to `super(props)`, we would lose access to `render()` and other methods defined therein. Now we finally get on to adding `state`:

```javascript
import React from "react";

class Counter extends React.Component {
    constructor(props){
        super(props);
        this.state = {count : 0}
    };
    
    render(){
        return (<div></div>)
    };
};

export default Counter;
```
We assign `this.state` to an object, wherein we can begin to define the things we want to keep track of within our component.

Great! Now we have access to `state` on our component, and can begin to work on the `increment/decrement` functionality. We use the *event handler* called `onClick=`, which is an attribute we can attach to a HTML button; it literally means "When someone clicks on this, execute whatever is in the brackets. So, simple right?

```javascript
import React from "react";

class Counter extends React.Component {
    constructor(props){
        super(props);
        this.state = {count : 0}
    };

    increment(){
        this.state.count++;
    };

    decrement(){
        this.state.count--;
    };

    render(){
        return(
            <div>
                <h1>The count is: {this.state.count}</h1>
                <button onClick={this.increment}></button>
                <button onClick={this.decrement}></button>
            </div>
        );
    };
};

```
**NB** - we pass a *reference* to `increment`/`decrement` instead of calling the function, this is because we want `onClick` to be synonymous with `this.increment()`. Passing `this.increment()` would assign `onClick=` to be the **return** result of `increment`, which is **nothing**.

Well here's where things get a little more finicky. Remember `this`? `this` refers to the **executing content** of an object; when we say `this` we are referring to the current object we are in upon execution of the code. So the flow chart would be:

`Enter class Counter -> Enter onClick -> call increment`

As we call `increment` from `onClick`, we are within the execution context of `onClick`. Within `onClick`, `state` is not defined, and so `this.state` of `onClick` is `undefined`. 

```javascript
import React from "react";

class Counter extends React.Component {
    constructor(props){
        super(props);
        this.state = {count : 0}
    };

    increment(){
        console.log(this.state) // undefined
        this.state.count++;
    };

    decrement(){
        console.log(this.state) // undefined
        this.state.count--;
    };

    render(){
        console.log(this.state) // {count : 0}
        return(
            <div>
                <h1>The count is: {this.state.count}</h1>
                <button onClick={this.increment}></button>
                <button onClick={this.decrement}></button>
            </div>
        );
    };
};
```
Remember, this is to do with where the function is **called**, not where it is defined. `this` **always** refers to where code is executed, not defined. `this.state` is only `undefined` within the `increment()`/`decrement()` function when called from `onClick={}`. If instead we call `this.increment()` from within our `class` render method, we are calling `increment` **within the execution context of our class Counter**. Again remember, forget where we *define* `increment`, or where we write `this.state` within `increment`: `this` is to do with *"Where am I right now as I'm executing the code"*. **Functions inherit their `this` context from where they are called**. For instance, in the below example, where am I when I call `this.increment()`?

```javascript
import React from "react";

class Counter extends React.Component {
    constructor(props){
        super(props);
        this.state = {count : 0}
    };

    increment(){
        console.log(this.state) // {count : 0}
        this.state.count++;
    };

    decrement(){
        this.state.count--;
    };

    render(){
        this.increment();
        return(
            <div>
                <h1>The count is: {this.state.count}</h1>
                <button onClick={this.increment}></button>
                <button onClick={this.decrement}></button>
            </div>
        );
    };
};
```
I am in a method attached to my `Counter` class. I am in `Counter.render()`, so my `this` context is `Counter`. I then enter `increment` and call `this` - which was inherited from where we called the function (the same `this` as has `Counter.render()`). Therefore, when i execute `console.log(this.state)` its like saying `console.log(Counter.state)` (except `Counter` isn't a variable). This is why we see `{count: 0}`.

```javascript
    increment(){
        console.log(this.state) // {count : 0}
        this.state.count++;
    };
```


 However, when we call `increment` or `decrement` from within our `onClick` handler, we are assigning `this` (within our `increment` and `decrement`) to be the context of `onClick`. In `onClick`, we do not define a `state` property, therefore when we call `this.state.count` we are saying `this.undefined.count`. It doesn't make sense to call the property `count` of `undefined` as by definition `undefined` means there is **nothing there**, therefore this will throw an error.
 
 To fix this, we need to do **one of two things**:

**1) Bind `this`.**

 This involves telling our class `Counter` that, whenever we call `increment`, we want to retain the current execution context (which, as we execute our constructor, is `Counter`):

```javascript
 class Counter extends React.Component {
    constructor(props){
        super(props);
        this.state = {count : 0}
        this.increment = this.increment.bind(this);
        this.decrement = this.decrement.bind(this);
    };

    increment(){
        this.state.count++;
    };

    decrement(){
        this.state.count--;
    };

    render(){
        return(
            <div>
                <h1>The count is: {this.state.count}</h1>
                <button onClick={this.increment}></button>
                <button onClick={this.decrement}></button>
            </div>
        );
    };
};

```
Now that's a lot of `this` flying about, but remember `this` refers to whatever the context is of **when we are running the code**: upon reaching `this` in the constructor, our context is the `Counter`. The line

```javascript
this.increment = this.increment.bind(this);
```

will tell our Counter to always use the execution context of the `Counter` whenever we call `increment`, *regardless of where we call `this.increment()`*. But binding `this` is a strange behavior and difficult to grasp, and I'm sure I've said `this` enough times for it to lose its meaning by now. The amount of **bolding** and *italics* in those last couple paragraphs should make clear just how easy it is to get confused when talking about the `this` object in JS, and how hard it can be to explain. So, we can do option 2 instead:

**2) Use arrow functions**

Remember I mentioned that arrow functions were slightly different to normal function declarations? The reason is because arrow functions **do not have a `this`**. Entering a normal function, we enter a new execution context and therefore have a new `this`. When entering an arrow function, however, as happens with any variable in javascript (see *lexical scoping*), when we call `this` in an arrow function JS will look within our function and check "do you define a variable called `this`?", and when it doesn't find one it goes up to the next outer function/object/block and checks "do YOU have a `this` variable?". This keeps going up the scope chain until a `this` is found. Therefore, we can instead say: 

```javascript
 class Counter extends React.Component {
    constructor(props){
        super(props);
        this.state = {count : 0}
    };

    increment(){
        console.log(this.state) // { count: 0 }
        this.state.count++;
    };

    decrement(){
        this.state.count--;
    };

    render(){
        return(
            <div>
                <h1>The count is: {this.state.count}</h1>
                <button onClick={() => this.increment()}></button>
                <button onClick={() => this.decrement()}></button>
            </div>
        );
    };
};

```
The logic for this is as follows:
1. We enter the `render()` method (`this` is that of `Counter`)
2. We enter `onClick` and call `this.increment()` (Our `this` context here is still `Counter.render()` as we are calling `onClick` **from** `Counter.render()`, which has `state` and `increment` defined).
3. We enter `increment`. Ordinarily, `increment` would take its execution context (and therefore `this`) from `onClick`. If `onClick` was a normal function, it would come with it's own `this` and overwrite the `this` of `Counter.render()` (Remember, when we **called** `onClick`, we were within `Counter.render()` and so had its execution context, when we call `increment` from `onClick`, we have a **new** execution context). However, as `onClick` is an arrow function, it does **not** have a `this` and so does not overwrite the `this` that it had when it was called within `Counter.render()`.
4. Failing to find a `this` within `onClick`, JS looks another level out - it looks at the execution context that `onClick` was called in: does this have a `this`?
5. Yes! Use that `this` when it is called in `console.log(this.state)`

There we go, we've overcome the `this` hurdle of this Counter!

**BUUUUUUUT** there's one more issue. If you take this code and try and run it, nothing will happen upon clicking the buttons. Nada. Zip. Ziltch. Your IDE might even throw a big red line under your code and tell you *"Don't mutate state directly"*. This goes back to the whole point of why we needed to use a class in the first place: we want to keep track of a variable called `count` *and re-render our component while keeping this updated variable and display its new value*. Directly touching `this.state` will update the `count` variable, but it will **not** re-render the component. Luckily, the smart React guys solved this for us - on that `React.Component` class we extend from, they define a method called `setState` which we use to mutate the state of our `Counter`. The reason being is that `.setState()` will cause a re-render of our Counter **after** our state is updated! We access it with `this.setState()` and pass in the updates we want to make: 

```javascript
 class Counter extends React.Component {
    constructor(props){
        super(props);
        this.state = {count : 0}
    };

    increment(){
        this.setState({count: this.state.count + 1});
    };

    decrement(){
        this.setState({count: this.state.count - 1});
    };

    render(){
        return(
            <div>
                <h1>The count is: {this.state.count}</h1>
                <button onClick={() => this.increment()}></button>
                <button onClick={() => this.decrement()}></button>
            </div>
        );
    };
};

```
**NB** - we only have to specify the values in state we wish to change, if we had more properties in our `state` we do not have to mention them when updating the `state` of `count`.

Finally, the above will work (although those buttons might be a bit small, let's add some text to them):

```javascript
 class Counter extends React.Component {
    constructor(props){
        super(props);
        this.state = {count : 0}
    };

    increment(){
        this.setState({count: this.state.count + 1});
    };

    decrement(){
        this.setState({count: this.state.count - 1});
    };

    render(){
        return(
            <div>
                <h1>The count is: {this.state.count}</h1>
                <button onClick={() => this.increment()}>Increment</button>
                <button onClick={() => this.decrement()}>Decrement</button>
            </div>
        );
    };
};

```
There we have it - the above is a functioning class-based counter component. Try it for yourself; replace your `index.js` file in the `src` directory of a CRA project with the following, and you too can have a cool little  `Counter` app.

**index.js**
```javascript
import React from "react";
import ReactDOM from "react-dom";

 class Counter extends React.Component {
    constructor(props){
        super(props);
        this.state = {count : 0}
    };

    increment(){
        this.setState({count: this.state.count + 1});
    };

    decrement(){
        this.setState({count: this.state.count - 1});
    };

    render(){
        return(
            <div>
                <h1>The count is: {this.state.count}</h1>
                <button onClick={() => this.increment()}>Increment</button>
                <button onClick={() => this.decrement()}>Decrement</button>
            </div>
        );
    };
};

ReactDOM.render(
    <Counter />,
    document.querySelector("#root")
);

```
---
#### Summary
We covered a lot of really heavy stuff, so I implore you to look for other resources and explanations. We covered the difference between class and functional components, how react works under the hood, the structure of a react app in CRA, props, and state.

 What we did **not** cover was using `state` in functional components. This is because this would necessitate an explanation of the **hooks** system, released in *React 16.8* in 2019, and this post has been long enough already. Rest assured, hooks are **great** and, in my opinion, much easier to understand than all the `this` tomfoolery using a `class` component. We also neglected the entirety of **lifecycle methods** like `componentDidMount` and `componentDidUpdate`. These would also necessitate their own post.
 
 A few resources to learn from: the [official react documentation](https://reactjs.org/docs/getting-started.html) is a *fantastic* resource to learn from too, the counter example is almost the same as the one defined there in their "Getting Started" page. The ReactJS [subreddit](https://www.reddit.com/r/reactjs/) is also great for reading around the subject. Stephen Grider's [Modern React](https://www.udemy.com/course/react-redux/) course on Udemy is also brilliant for initial learning, although you might have to wait for a deal on Udemy to get it for ~Â£10 (the sales come by very frequently so keep an eye out).

---

Quick note: the eagle-eyed may have spotted we replaced the 

```javascript
increment(){
    this.setState({count: this.state.count++});
};
```
line with 

```javascript
increment(){
    this.setState({count: this.state.count + 1});
};
```
When we call the `++` operator instead of `+1`, we are *directly mutating* the variable: so 
```javascript
this.setState({count: this.state.count++});
```
literally means "Set count to be the current value of `this.state.count`, then *directly* increase `this.state.count` by 1", which is *exactly* what we were trying to avoid in the first place (direct mutation of state). In most other cases `++` and `+1` are synonymous, but in this little corner case we must use `+1` due to how mutability works.

**For extra points**, some of you might be thinking "But I thought we *couldn't mutate primitive values like numbers?* Well you'd be right! Let's say

```javascript
let x = 5;
```
and that this value is stored in memory location 0x32EH42A on our computer. When we call 

```javascript
x = x + 1;
```
we are saying "read the value at memory location 0x32EH42A, then perform a separate operation to increase its value by one, then overwrite memory location 0x32EH42A with the new value". Notice how nothing we have done has *changed* the value of `5` that was originally there, we just threw it out and replaced it with a `6`, we didn't *convert* a `5` into a `6`. It is somewhat cheating to say we cannot mutate a primitive, as usually when we think of variables we usually think of them ***as*** their value. `x` *is* `5`, `name` *is* `"josh"`, etc. However, in reality it's a little more complicated. `x` *isn't* `5`, `x` is a *container*, a memory location, where we have chosen to *store* `5`. We can easily throw away `5` and *replace* it without directly altering it to be a `6`.