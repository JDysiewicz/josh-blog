---
title: "How JS Runs (1): Stepping Through Code"
slug: "how-js-runs-1"
author: "Joshua Dysiewicz"
date: "19 October 2020"
readingTime: "ðŸ“– 5 min"
spoiler: "A deep dive into how JS code actually runs, and how we can use this mental model to help explain all the cool stuff in JS."
---

## Disclaimer
This is one of those **deep-dives**. Here we will slowly step through what is actually happening when we run a piece of JS code - be it *React*, *NodeJS*, or plain old *vanilla JS*. I believe that knowing this is **essential** to understanding how JS is working; it will make it easier to **debug** your code, prevent **mistakes** from being made, and allow you to **reason** about why a piece of code works how it does. It is also essential to understanding more advanced topics, such as **promises** and **async/await**, which are paramount to what makes JS a **great language**. The following is heavily influenced by Will Sentance's [JavaScript: The New Hard Parts](https://frontendmasters.com/courses/javascript-new-hard-parts/). For a more thorough explanation, I highly recommend checking out his stuff!

This is intended to be a **four-part series**. In this section we shall explore the fundamental level of how JS code executes. In part 2, we will apply this to **closures** to explain how they fall out of this system. We shall then get our hands dirty and talk about **asynchronous JavaScript**, adding a couple important things to our mental model of how JS code runs. We shall then bring everything together for the last section, where we will talk about **iterators/generators** and use them to rebuild the **async/await functionality from scratch**.

## Principles of JavaScript

JS can be thought of as being composed of **three** main parts:

1) A **thread of execution**
2) **Memory**
3) The **call stack**

Because Javascript is a **single threaded** language, there can only ever be **one** thread of execution (ToE). This means JS can only do *one thing at a time*; it will never execute two lines of code simultaneously. Furthermore, Javascript is a **synchronous** language, meaning *it must finish the current line of code before moving onto the next*. The combination of the thread of execution (which executes code) and memory (which holds variables) forms what we call an **execution context**. When we load up a JS file, we enter a new **execution context** as our ToE spins up and begins executing our code line by line, and the **global memory** is used to keep track of variables and their values.

Let's run through the following code very slowly and be explicit about what is happening as it runs.

```javascript
const num = 3;                  // Line 1

function addTwo(input){         // Line 3
    const result = input + 2;   // Line 4
    return result;              // Line 5
};

const output = addTwo(num);     // Line 8

const newOutput = addTwo(10);   // Line 10
```

1. **Line 1**: We set aside a section in the **global memory** and call it *num*, then place the value *3* inside it.

2. **Line 3**: We set aside a section in the **global memory** and call it *addTwo*, then place in the *entire function definition*.

![Figure 1 - The state of our global memory up to this point.](./global-memory-1-actual.PNG)

3. **Line 8**: We skip over the rest of the function, as we are not executing it yet. Here, we set aside a section in the **global memory** and call it *output*, and we *cannot place anything into it yet*. This is because we must first evaluate the right-hand side of our statement - we are assigning the value to be placed into *output* as the **return value** from executing *addTwo* with the *argument* of *num* (which we know to be **3**).

4. **Line 4**: We have entered a new function, and so now have a **new execution context**. Our ToE has **left** the *global execution context* and has now entered the execution context of *addTwo*. As such, we have a **new memory storage**, which we shall call **local memory** (local to the function, *addTwo*). We first set aside some space in this **local memory** and call it *input*, and we place into the memory the value that *addTwo* was called with; **num/3**. We then set aside room in **local memory**, call it *result*, and into it we place the evaluation of `input + 2`, which we know to be **5**.

5. **Line 5**: We hit a **return**, which ejects our ToE from the current **execution context** and goes back to wherever it was before it entered the execution context of *addTwo*. While returning, we pull out the value stored in the **local variable** called **result**, and use this as the value we assign to *output*. After returning - **everything in that local memory is deleted, as is the execution context**. 

![Figure 2 - A visualisation of the above two steps, with the green arrow showing our ToE. Outisde the box is the global execution context, inside is the execution context of addTwo. Local memory only exists within addTwo's execution context, not in the global execution context. The blue arrow shows the value for "result" being pulled out of Local Memory and placed into "output" in Global Memory due to the return statement.](./execution-context-1-actual.PNG)

6. **Line 10**: Back in the global execution contenxt, we set aside space in **global memory**, call it *newOutput* and assign to it *nothing for now* as we need to evaluate the right-hand side first, which invokes *addTwo* again.

7. **Line 4**: We enter a **new execution context** again (completely separate from the previous addTwo execution context as this is a separate invocation of the function), set aside space in **local memory**, call it *input* and place into it the value we invoked *addTwo* with - **10**. We then set aside more space in **local memory**, call it *result* ad place into it the evaluation of the right-hand side; **12**.

8. **Line 5**: We hit a return, and eject from the execution context whilst returning the value inside *result*. We assign this value to *newOutput*, which invoked *addTwo* in order to get its value. By ejecting from this execution context (our ToE exits), **everything in the local memory of this execution context is once again deleted** - *input* and *result* now cease to exist entirely.

## UP TO HERE - ADD IN SIMILAR DIAGRAM TO THAT ABOVE

We went through that quite verbosely, however it's important to not skip over steps whilst we build a good mental model for how JS code executes. Now, we can visually see the different execution contexts this way, and can imagine out ToE weaving in and out of them. However, the JS engine that is actually running our code has no visualisation of this. Therefore, it uses the **call stack** to keep track of which execution context it is currently in, and which execution context to return to after it finishes the current execution context.

We start off at **1** where we only have the **global** execution context on the stack, then we hit **Line 8** and enter a new execution context, and so we **push** *addTwo* onto the call stack (**2**). After we hit a **return**, we exit the current execution context, **popping** it off the stack (**3**). Once the **global** execution context has completed (all code has finished running), our program stops as **global** is popped off the stack and our stack becomes empty.

**This is, fundamentally, what JS is doing all the time.** There are some additions, important additions, however at its most basic level, this is how JS code is running.
