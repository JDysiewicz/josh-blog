---
title: "React: Lifecycle Methods"
slug: "react-lifecycle-methods"
author: "Joshua Dysiewicz"
date: "21 September 2020"
readingTime: "ðŸ“– 10 min"
spoiler: "The lifecycle of a react component, and the methods associated with each."
---

# Component Lifecycle and Lifecycle Methods (~ 10 min)

## Component Lifecycle
Every component we make in React, functional or class-based, has a certain series of stages it goes through. In human life, we tend to say the progression is:
`baby -> toddler -> child -> teen -> adult`
If we add to this that `adult` then goes on to have a baby, we loop right back to the start again:
```javascript
baby -> toddler -> child -> teen -> adult -> baby -> toddler...
```

This is similar to the lifecycle of a **component** in React which is roughly:

```javascript
Initialized -> Props passed -> component mounts -> component rendered -> new state/props causing a re-render -> component re-renders ... -> component unmounts
```
Therefore, the *lifecycle* of a component just refers to the stages involved in displaying the component to a user. Let's look at each of these stages in detail - however to do so we'll need to define what **lifecycle methods** are as they play a key role in understanding the **stages** of component lifecycle.

## Lifecycle Methods
Remember when we define a `class` component, we `extend` a `React.Component`?

```javascript
import React from "react";
class App extends React.Component{
    ...
};
```
Well one of the reasons is because it gives us access to specific *methods* defined on `React.Component`. These specific methods are the titular **lifecycle methods**. `render()` is an example of one of these methods, as is `constructor()` to a certain extent!

```javascript
import React from "react";
class App extends React.Component{
    render(){
        return (<div>Render is a lifecycle method!</div>)
    };
};
```

```javascript
import React from "react";
class App extends React.Component{
    constructor(props){
        this.state = {name: "josh"};
    };
    render(){
        return (<div>So is constructor!</div>)
    };
};
```

These lifecycle methods will run at different stages during a component's lifecycle, hence the name. The `render()` method obvious runs during the `render component` stage of the component lifecycle, but what about the others? Let's dive into the **three** main stages of component lifecycle in react: *Mounting, Updating, and Unmounting*!

## Component Lifecycle Stages and Methods

### Mounting
*Mounting* is the process of adding a *node* (an HTML element) to the (real) DOM and showing the component to the user. Think of this as a stage magician about to perform: he first enters the stage behind a curtain sets everything in place for his performance (`constructor()`), then the curtain is lifted and the stage is revealed to the audience (`render()`), after which the magician will perform his first magic trick (`componentDidMount()`). These are the steps involved in the mounting process: we define a `React element` using our `constructor()` function, we then `render()` this `React element` into a `DOM node` which is inserted into the DOM. After which we run another lifecycle method called `componentDidMount()`.

#### `constructor()`
The constructor function will run when a component is *first* declared. This is the first step in *mounting*, whereby we define a component as a class or function and insert it into the *virtual* DOM.

**index.js**
```javascript
import React from "react";
import ReactDOM from "react-dom";

import App from "./components/App";

ReactDOM.render(
    <App />, // App first declared here, therefore constructor runs at the initialization stage
    document.querySelector("#root")
);

```

```javascript
import React from "react";
class App extends React.Component{
    constructor(props){ // Before component is rendered, this function runs to setup the state
        super(props);
        this.state = {name: "josh"};
    };
    render(){
        return (<div>So is constructor!</div>)
    };
};
```
The virtual DOM is a React-specific representation of the DOM which uses `React elements` in place of `DOM nodes`. Remember those `React.createElement` calls before? Those are the "virtual DOM nodes" which React uses to create its virtual DOM. However, users cannot see the virtual DOM, we must actually input these into the *real* DOM. This is what the `render()` lifecycle method does, and is the second step in our mounting phase.

#### componentDidMount()
This lifecycle method runs *straight away* after the component is (*successfully*) mounted (after `render()` successfully places the `React elements` into the web page's DOM). This makes it a great place to setup initial data, such as creating a network request to retrieve some data to populate `state`.

```javascript
import React from "react";
class App extends React.Component{
    constructor(props){
        super(props);
        this.state = {data: ""};
    };

    componentDidMount(){
        let dataFromNetwork = // request.get("/api/myStringData")
        this.setState({data: dataFromNetwork});
    };

    render(){
        return (<div>So is constructor!</div>)
    };
};
```

Rightly you may be thinking "couldn't we just load initial data like that into the constructor instead?" Well, you can!

```javascript
import React from "react";
class App extends React.Component{
    constructor(props){
        super(props);
        this.state = {data: () => {
            let dataFromNetwork = // request.get("/api/myStringData");
            return dataFromNetwork;
        }};
    };

    render(){
        return (<div>So is constructor!</div>)
    };
};
```

Here we assign the initial value of `this.state.data` to be the `return` value from a function which makes a network request. This is perfectly valid, however is often avoided for three reasons:
1) It's a little **messy** to start putting functions into your initial state.
2) We like to keep things **modular** - the constructor should be a place we *initialize* the values we want, it's often useful to keep the logic of initializing values separate to that of populating their them.
3) Our component may **fail to mount**. In that case, we wouldn't want to make our network request - for a slightly contrived example for this, let's say we need to make 1000 network requests for each component, and we render 100 of these components to the user. Something went wrong, and now each of the components fail to mount, however the network request was made in the `constructor()` function which occurs **at initialization**. The constructor doesn't care that the component failed to mount, it will go ahead and make that request. Therefore we make 100,000 network requests which are useless as the user will never see their result, which could end up costing **money** if the network we use is a *per-request* basis, or could crash the network entirely.





### Updating
After our component is mounted and initial setup is done (`componentDidMount()`), we now enter the *Updating* phase. During this phase, the component remains stationary on standby, waiting to be told to re-render. This happens for one of **three** reasons:
1) New **props**
2) New **state** (via `setState()` not direct mutation!)
3) `forceUpdate()`

`forceUpdate()` is another method available to us by extending `React.Component`, and does exactly what you'd think. It forces the react component to re-render itself without changing `state` or `props`. This is kind of a brute-force approach, and so is often avoided for a more "React-like" way of doing things.

The two more common reasons for a re-render are new `props` incoming, or updating **state** using `setState()`. The reason for this is that usually a change in props or state signify some change to the component, a change which is often wanted to be displayed to users (or at least something else to be displayed due to the change). This is why we **never** directly mutate the `this.state` object - it completely skips the rendering process!.

After new props or state (or `forceUpdate()` is called within the component), a component will once again run its `render()` method. After this, another lifecycle method is called: `componentDidUpdate()`. For clarity: the timeline in lifecycle methods of the *updating* phase is `new props/state -> render() -> insert into real DOM -> componentDidUpdate()`. **NB** - `componentDidMount()` is only called after the **first initial render**; each time after that only `componentDidUpdate()` will run.

#### `componentDidUpdate()`
Much like `componentDidMount()`, the naming of this function is perhaps a better indicator of its purpose than any explanation could do. This method runs *after* the `render()` caused by new state or props.

```javascript
import React from "react";
class App extends React.Component{
    constructor(props){
        super(props);
        this.state = {count: 0}
    };

    componentDidUpdate(){ // Will run each time the button is clicked that would update state with this.setState()
        console.log("Hey, I just updated!");
    };

    increment(){
        this.setState({count : this.state.count + 1});
    };

    render(){
        return (
            <div>
                <h1>Count : {count} </h1>
                <button
                onClick={() => this.increment()}>Inc</button>
            </div>
            )
    };
};
```
Perhaps we could do something more interesting than just `console.log` each time our button is clicked: perhaps we could change the color of the `button` each time it is clicked, as well as increasing the count?

```javascript
import React from "react";
class App extends React.Component{
    constructor(props){
        super(props);
        this.state = {count: 0, style: {color: "blue"}}
    };

    componentDidUpdate(){ 
        let newColor = ["red", "yellow", "green"].//Select random
        this.setState({style: {color: newColor}});
    };

    increment(){
        this.setState({count : this.state.count + 1});
    };

    render(){
        return (
            <div>
                <h1>Count : {count} </h1>
                <button
                style = {this.state.style}
                onClick={() => this.increment()}>Inc</button>
            </div>
            )
    };
};
```
The implementation of selecting a random color will be left as an exercise to the reader, however this should give some insight as to the type of thing we can accomplish with `componentDidUpdate()`. 

### Unmounting
The last life-stage for a React component is when it is being removed from the DOM. This is perhaps the easiest stage to understand: we do *not* render anything or call `setState` because the component is being removed from the DOM anyway. All we do here is *unsubscribe* from any `listeners` we may have subscribed to in `componentDidMount()` - or things to that nature. This is the stage where we clean up, really. If you setup a `WebSocket` (a kind of continual listening out for network requests), here is where you'd remove that. If you set up any `setInterval()`s or other periodically done events, you'd remove them here too. If you *didn't* setup any of these to begin with, then *good news!* You can completely ignore this stage.

However, it is an important part of the lifecycle when you *do* do these things. So where do we actually do this?

#### `componentWillUnmount()`
This is the final lifecycle method we will really talk about. As said above, here is where we clean up after ourselves.

```javascript
import React from "react";
class App extends React.Component{

    componentDidMount(){ 
        this.interval = setInterval(() => alert("Hey I'm still here!"), 5000)
    };

    componentWillUnmount(){
        clearInterval(this.interval);
    };

    render(){
        return (
            <div>
                Hello, world!
            </div>
            )
    };
};
```
In another slightly contrived example, here we attach an `interval` to our component which will send an `alert` to the user every **5** seconds (5000 milliseconds = 5 seconds). After the user (inevitably) leaves our page, we don't want that `alert` to still be pinging them every few seconds, so we call the `clearInterval` to remove it once the user leaves and our component is unmounted.

## Summary
That's really all there is to component lifecycle and lifecycle methods. There *are* other lifecycle methods out there, like `componentDidCatch()` for error handling, or `shouldComponentUpdate()` for deciding if a particular action should cause a re-render or not, however these are used far less frequently than `componentDidMount()`, `componentDidUpdate()` or `componentWillUnmount()`. There are **three** main component lifecycle stages:
1) Mounting : `constructor() -> render() -> componentDidMount()`
2) Updating : `new props/state -> render() -> componentDidUpdate()`
3) Unmounting: `componentWillUnmount()`

Access to these lifecycle methods, along with `state`, was the main reason why many preferred `class` components to functional components, and why `class` components were the *only* option for a long time. However, nowadays we have access to the react **Hooks** system which allows us to use State and create a similar Effect to the lifecycle methods detailed here. These days it's mainly a personal preference thing; there are a *handful* of things that each do better than the other (`Error Boundaries` can still only exist on `class` components, however functional components/hooks are neater and have less overhead), but it's worth it learn both and then pick your favorite.